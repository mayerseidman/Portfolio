{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport MessageProcessor from './MessageProcessor';\nimport ChatBotUtil from './ChatBotUtil';\nimport ActionBar from './actionbar/ActionBar';\nimport Messages from './messages/Messages';\n/**\n * A `ChatBot` component builds a chat based on messages received from callbacks, handles user interactions and calls callbacks.\n *\n * <ChatBot onGetStarted={onGetStarted} getStartedButton={ChatBotUtil.makeGetStartedButton('Get Started')} />\n */\n\nvar ChatBot = function (_Component) {\n  _inherits(ChatBot, _Component);\n\n  function ChatBot(props) {\n    _classCallCheck(this, ChatBot);\n\n    var _this = _possibleConstructorReturn(this, _Component.call(this, props));\n\n    _this._onGetStarted = _this._onGetStarted.bind(_this);\n    _this._onQuickReplyAction = _this._onQuickReplyAction.bind(_this);\n    _this._onTextInputSubmit = _this._onTextInputSubmit.bind(_this);\n    _this._onProcessed = _this._onProcessed.bind(_this);\n    _this.state = {\n      actions: props.getStartedButton ? [props.getStartedButton] : [],\n      messages: [],\n      messageProcessor: new MessageProcessor(_this._onProcessed)\n    };\n    return _this;\n  }\n\n  ChatBot.prototype.render = function render() {\n    var _this2 = this;\n\n    var messages = this.state.messages.concat(this.state.messageProcessor.isProcessing ? [{\n      type: 'typing',\n      isInbound: false\n    }] : []);\n    return React.createElement('div', {\n      className: 'I-ChatBot'\n    }, React.createElement(Messages, {\n      messages: messages\n    }), React.createElement(ActionBar, {\n      actions: this.state.actions.map(function (action) {\n        switch (action.type) {\n          case 'get-started':\n            return Object.assign({}, action, {\n              onAction: _this2._onGetStarted\n            });\n\n          case 'quick-reply':\n            return Object.assign({}, action, {\n              onAction: _this2._onQuickReplyAction\n            });\n\n          case 'text-input':\n            return Object.assign({}, action, {\n              onSubmit: _this2._onTextInputSubmit\n            });\n        }\n      })\n    }));\n  };\n\n  ChatBot.prototype.startOver = function startOver() {\n    var _this3 = this;\n\n    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    this.state.messageProcessor.reset();\n    this.setState(function (prevState, props) {\n      return {\n        actions: props.getStartedButton ? [props.getStartedButton] : [],\n        messages: message && !_this3.props.getStartedButton ? [message] : []\n      };\n    });\n\n    if (!this.props.getStartedButton) {\n      this._processNext(this.props.onGetStarted());\n    }\n  };\n\n  ChatBot.prototype._addMessage = function _addMessage(message) {\n    this.setState(function (prevState, props) {\n      return {\n        actions: message.actions || [],\n        messages: prevState.messages.concat(message)\n      };\n    });\n  };\n\n  ChatBot.prototype._onGetStarted = function _onGetStarted(text) {\n    this._addMessage(ChatBotUtil.userTextMessage(text));\n\n    this._processNext(this.props.onGetStarted());\n  };\n\n  ChatBot.prototype._onProcessed = function _onProcessed(message) {\n    this._addMessage(message);\n  };\n\n  ChatBot.prototype._onQuickReplyAction = function _onQuickReplyAction(text, callback) {\n    this._addMessage(ChatBotUtil.userTextMessage(text));\n\n    if (callback) this._processNext(callback());\n  };\n\n  ChatBot.prototype._onTextInputSubmit = function _onTextInputSubmit(value, callback) {\n    this.setState(function (prevState, props) {\n      return {\n        actions: []\n      };\n    });\n    var hasValue = value && value.length;\n    if (hasValue) this._addMessage(ChatBotUtil.userTextMessage(value));\n\n    this._processNext(callback(value), hasValue);\n  };\n\n  ChatBot.prototype._processNext = function _processNext(next) {\n    var _this4 = this;\n\n    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (!next) return;\n    setTimeout(function () {\n      (Array.isArray(next) ? next : [next]).map(function (message) {\n        return _this4.state.messageProcessor.process(message);\n      });\n\n      _this4.forceUpdate();\n    }, delay ? 500 : 0);\n  };\n\n  return ChatBot;\n}(Component);\n\nChatBot.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * A `<ChatBot>` callback fired immediately on mounting if no get started button object passed during initialization, otherwise when `startOver` method is called.\n   * Returns an array of chat message objects to display in a chat.\n   *\n   * @type Function() -> [Object]\n   */\n  onGetStarted: PropTypes.func.isRequired,\n\n  /**\n   * An optional object that describes get start button.\n   * Use ChatBotUtil.makeGetStartedButton method for creating an object with button title.\n   *\n   * @type Object\n   */\n  getStartedButton: PropTypes.object\n} : {};\nexport default ChatBot;","map":null,"metadata":{},"sourceType":"module"}